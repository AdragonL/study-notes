/*
 * @Author: DragonL
 * @Date: 2022-03-03 15:45:06
 * @LastEditors: DragonL
 * @LastEditTime: 2022-05-23 11:23:06
 * @Description:
 */
// DNS解析
// 发起TCP连接
// 发送HTTP请求 （三次握手）
// 服务器处理请求并返回HTTP报文
// 浏览器解析渲染页面
// 四次挥手
// 连接结束

// DNS是一个递归的过程
// 例子： www.google.com    .=>.com=>google.com. => www.google.com.
// 这个过程需要消耗大量的时间 所以需要有DNS缓存来解决这个问题

//DNS缓存有各级的缓存 顺序是浏览器缓存，系统缓存（host文件），路由器缓存，ips服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存

//DNS负载均衡
// 在输入一些比较大型的网站的时候通常响应的都不是同一台服务器，因为访问量巨大，所以DNS返回一个合适的机器IP给用户，再去访问

//DNS优化手段
// DNS预解析，就是通过对需要请求数据的域名进行提前的解析来减少延迟，但是不能是对同域的域名下，只能是跨域的域名；通过dns-prefetch解析出来的ip会提前放在本地缓存中，这样就免去了dns解析的过长时间
// 格式：<link rel="dns-prefetch" href="https://baidu.com/"> 



//发起请求
//发起请求的是TCP请求 对于TCP的数据格式分为报头和数据两个方面：
//报头方面是16位源端口号还有16位目的端口号
//32位的序号，32位确认序号
//4位首部长度（保留6位），标志位6位，16位窗口大小
//16位检验和，16位紧急指针

//端口号是用于保证传输的地址
//序号是用于判断数据传输的有序性
//确认号是 表明之前的数据已经收到，期待收到下一次的字节序号
//首部长度用于表明数据的偏移量
//控制位 URG=1表明有紧急指针； ack=1 确认号字段有效； PSH =1 用于两个进程进行交互是希望马上收到对方响应 ；RST=1 表明有严重差错需要释放连接，然后再重新建立连接；
//SYN在连接建立是用与同步序号，当SYN =1 ，ack =0 表明是连接请求报文， 同意连接则syn =1，ack =1；FIN =1 表明数据发送完毕，要求释放；
//校验和：奇偶检验，对这个报文进行16位的计算，接收端进行验证；


// 三次握手(SYN是同步位，ACK是确认位)
// 第一次握手 发送 SYN =1 seq = x
// 第二次握手 发送 SYN= 1 ACK=1 seq = y ack=x+1
// 第三次握手 发送 ACK =1 ack = y+1 seq = x+1


// 四次挥手
// FIN = 1  seq = u
// ack =u +1 seq =v ACK=1
// FIN = 1 ACK=1 ack = u+1 seq = w
// ack = w+1 seq =u+1 ACK=1
// 为什么在第四次挥手的时候客户端需要等待2MSL（最长报文段寿命）？
// 因为服务端会因为发了FIN的那段报文没有收到回复而重发，对于客户端就是能收到这对时间所有的报文

//为什么建立是3次 关闭是4次
//因为在关闭的时候服务端收到的信息就是说明对方不再发数据，但是还能收到数据，所以服务端可以将剩下的数据全部发完才发fin给对方，ack和fin分开，所以多一次；


//发送http请求
//http :80/8080 https:443

//post和get的区别
// 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
// 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
// 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
// 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
// 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)




// http缓存
// 强缓存和协商缓存 （这部分熟悉）
// 强缓存就是：cache-control ：public，private,max-age，no-cache，no-store’；expired
// 协商缓存就是：Last-Modified：if-Modified-Since，if-Unmodified-Since；Etag:If-None-Match

//from disk cache 和from memory cache
//disk cache就是硬盘缓存，memory cache就是内存缓存，内存缓存就是页面缓存 关闭页面就没有了，硬盘缓存是一直存在
// 1、先查找内存，如果内存中存在，从内存中加载；
// 2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；
// 3、如果硬盘中未查找到，那就进行网络请求；
// 4、加载到的资源缓存到硬盘和内存；

// 问到可以加分：启发式缓存 ！！！！
// 如果响应中未显示Expires，Cache-Control:max-age或者Cache-Control:s-maxage,并且响应中不包含其他关于换粗你的限制，缓存可以使用启发式方法计算新鲜度寿命，通常即使根据响应头的2个时间字段Date减去Last-Modified值得百分之十作为缓存时间

//浏览器地址栏中写入URL，回车
    // 浏览器发现缓存种有这个文件，不用请求，直接去缓存拿
    // f5 浏览器发送一个请求带上if-modify-since
    // ctrl +F5 把缓存种的文件删了，去服务器请求一个完整的资源文件下来，强行更新


//服务器处理请求返回报文
    
// 状态码：
// 1：已接受继续处理；
// 2：成功接受；
// 3：重定向；301永久重定向 302临时重定向 304协商缓存命中是返回这个状态码
// 4：客户端错误；403原因有很多，比如法律禁止、信息敏感，没有权限；404 资源未找到 413请求体数据过大
// 5：服务端错误；500 服务器出错；501 功能不支持； 503 服务器很忙


//浏览器解析渲染页面

//解析html形成dom树
//解析css形成cssom树
//合并dom树和cssom树构建渲染树（中途遇到script会停止渲染）
//渲染树 按顺序展示在屏幕上得一系列矩形，带字体颜色和尺寸等
//布局 根据节点树上得节点布局在屏幕正确位置
//绘制 遍历渲染树所有节点，为节点找到对应样式


//其中会出现回流和重绘
//回流一定会引起重绘，重绘不一定能引起回流；
//回流就是改变布局，大小变化，内容变化，激活伪类，查询属性或调用某些方法；
//重绘就是像颜色，透明；

//这里可能还会问到 页面渲染优化
//HTML文档结构层次尽量少，最好不超过六层；
//少量首屏样式内联到标签中
//样式结构层次尽量简单
//在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流
//尽量使用class来操作样式和动画
//动画尽量使用绝对定位或固定定位的元素
//隐藏在屏幕外或页面滚动时尽量停止动画
//缓存DOM查找
//涉及多域名的网站可以开启域名预解析



// 参考：https://juejin.cn/post/6928677404332425223

// 1,7,6,8,2,4,3,5,9,11,10,12