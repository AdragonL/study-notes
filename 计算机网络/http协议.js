/*
 * @Author: DragonL
 * @Date: 2022-05-12 16:35:20
 * @LastEditors: DragonL
 * @LastEditTime: 2022-05-23 11:13:48
 * @Description:
 */

// 参考：https://juejin.cn/post/6844904001528397837

// HTTP特点：
// 灵活可拓展 一是语法上的自由 二是可以上传多种类型的文件图片，视频等
// 可靠传输 基于TCP/IP
// 请求-应答 有来有回
// 无状态 通信过程中上下文信息，每次请求都是独立的 ，不需要保留状态信息

// HTTP缺点
// 无状态  在长连接中就是需要报错大量上下文信息
// 明文传输  暴露报文信息给外界
// 队头阻塞问题  当http开启长连接共用一个tcp连接，当前请求耗时过长，其他请求只能处于阻塞状态



// HTTP 0.9
// 由于只需要传输一个很小的html文件
// 所以只有一个请求行，并没有http请求头和请求体
// 服务器没有返回头信息，因为不需要告诉客户端太多信息
// 返回的文件内容的以ASCII字符来传输，因为都是HTML文件，所以用ASCII字节码来传输；

// HTTP 1.0
// 为了支持更多类型的文件 例如Js文件,css,图片,音频,视频等文件，从而添加了请求头和响应头
// 但是不支持长连接，当需要的文件越来越多的时候每一次请求文件都需要经历一次tcp连接
// 引入Cache机制，用户代理，状态码等基础信息
// pragma,expires(绝对时间)

// HTTP 1.1
// 并发连接 （对同一个域名默认允许同时建立6个TCP持久连接）
// 域名分片（通过多开域名，然后指向同一个服务器来避开连接数量的限制）
// 管线化（通过多个HTTP请求整批提交给服务器的技术，不过服务器依然需要根据请求顺序回复浏览器请求，尝试用于解决队头拥塞的问题,最后还是放弃）
// 提供虚拟主机的支持（同一台物理主机可以绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，因此新增了Host字段，用来表示当前的域名地址，这样服务器可根据不同的host值做不同处理）
// 支持长连接 （填补HTTP 1.0 的问题）
// 对动态生成的内容提供支持（服务器会将数据分割成若干个任意大小的数据块，里面有对应着上个数据块的长度，最后一个为0长度来作为发送数据完成的标志）
// cache-control( max-age是相对时间)、last-modified（协商缓存，服务端）、if-modified-since（客户端 两个值对比看看是否过期）、etag（唯一标识符 服务端）、if-none-match（客户端） etag和last modified都有的时候先看etag,但是要两者都满足的情况下才能触发304

// HTTP 2.0
// 头部压缩
// 多路复用（通过二进制分帧 将头和body转换为二进制帧，然后在tcp连接上进行多个帧的通信）（这是为了避免TCP上的慢启动和TCP连接之间竞争带宽的问题，但是HTTP只是有一个TCP连接）
// 设置请求优先级 （服务器可以根据优先级决定先处理那个请求）
// 服务器推送 能够向客户端发送消息
// 缺点：如果出现因为网络请求等问题发生丢包情况，HTTP 2.0会阻塞该连接上所有请求，而HTTP1.1因为是并发连接原因反而还有5个链接可以传输数据

// TCP
// 拥塞控制 - 慢启动 - 拥塞避免 - 快重传 - 快恢复
// 超时重传 （在规定时间内没有得到回复重新发送请求）

// 为什么有了Last-Modified还要用etag？
// 防止Last-Modified变了，但文件内容没变的情况下，浏览器需要重新请求服务器
// 防止文件在1s内发生变化，而Last-Modified不变

// 用户行为如何触发缓存？
// 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
// 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
// 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。


// HTTPS
// 在http和tcp之间添加一个ssl层来对通信协议进行加密；
// tls是ssl的后续版本
// 可以用于身份验证和加密
// tls上使用对称加密和非堆成加密两种版本；


// 对于https握手的流程：
// 商定双方通信所使用的tls版本；
// 确定双方需要使用的密码组合；
// 客户端通过服务端的公钥和数字证书上的数字签名验证服务端的身份；
// 生成会话密钥，用于握手结束的对称加密

// 1.client hello消息：客户端通过发送该消息向服务端发起握手请求，该消息包含了客户端所支持的tls版本和密码组合以供服务端进行选择，还有一个client random的随机字符串；
// 2.server hello消息：服务器发送server hello消息对客户端进行回应，该消息包含数字证书，服务端选择的密码组合，和server random随机字符串和包含服务器公钥的加密数据；
// 3.验证：客户端对服务端发来的证书进行验证，确保对方的合法身份，具体由检查数字签名，验证证书链，验证证书的有效期，检查证书的撤回状态；
// 4.premaster secret 字符串：客户端向服务器发送另一个随机字符串premaster secret预主密钥，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密；
// 5.使用私钥：服务器使用私钥解密premaster secret
// 6.生成共享密钥：客户端和服务器均使用client random，server random和premaster secret，并通过相同的算法生成相同的共享密钥key；
// 7.客户端就绪：客户端发送经过共享密钥key加密过的finished信号
// 8.服务端就绪：服务端发送经过共享密钥key加密过的finished信号
// 9.达成安全通信：握手完成，双方使用对称加密进行安全通信


// https绝对是安全的吗？
// 不是可以通过中间人攻击
// 通过dns劫持，客户端发送请求到中间人的服务器，可以从中获取客户端的加密算法来解密，中间人以客户端的内容想向服务端发起请求，
// 中间人凭借官方网站的堆成加密算法来对内容解密，然后再通过与客户端的对称加密算法来将内容加密传输，由于缺少对证书的验证，所以客户端发起的是https请求，但是客户端完全不知道自己的网络已被拦截，内容被中间人全部窃取；

// https如何防止中间人的攻击
// 证书锁定
// 在客户端代码中内置仅接受指定域名的证书，不接受操作系统或浏览器内置的CA根证书对应的任何证书；
// 公钥锁定
// 提取证书的公钥内知道客户端。通过与服务端对比公钥值来验证连接的正确性